package tup

import (
	"encoding/binary"
	"errors"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
	"github.com/TarsCloud/TarsGo/tars/protocol/res/requestf"
	"github.com/TarsCloud/TarsGo/tars/util/tools"
)

// TUPStruct generated by tars2go
type TUPStruct interface {
	ReadFrom(_is *codec.Reader) error
	ReadBlock(_is *codec.Reader, tag byte, require bool) error
	WriteTo(_os *codec.Buffer) error
	WriteBlock(_os *codec.Buffer, tag byte) error
}

// TarsUniPacket - Go implement
type TarsUniPacket struct {
	IVersion     int16
	CPacketType  int8
	IMessageType int32
	IRequestId   int32
	SServantName string
	SFuncName    string
	Buffer       PacketBuffer
	ITimeout     int32
	Context      map[string]string
	Status       map[string]string
}

// NewTarsUniPacket - With TUP Version 2
func NewTarsUniPacket() TarsUniPacket {
	return TarsUniPacket{
		IVersion: 2,
		Buffer: PacketBuffer{
			IVersion: 2,
			NewData:  make(map[string][]byte),
			Data:     make(map[string]map[string][]byte),
		},
	}
}

// NewTarsUniPacketVersion3 - With TUP Version 3
func NewTarsUniPacketVersion3() TarsUniPacket {
	return TarsUniPacket{
		IVersion: 3,
		Buffer: PacketBuffer{
			IVersion: 3,
			NewData:  make(map[string][]byte),
			Data:     make(map[string]map[string][]byte),
		},
	}
}

// Init for TarsUniPacket - With TUP Version 2
func (tup *TarsUniPacket) Init() {
	tup.IVersion = 2
	tup.Buffer = PacketBuffer{
		IVersion: 2,
		NewData:  make(map[string][]byte),
		Data:     make(map[string]map[string][]byte),
	}
}

// InitVerion3 for TarsUniPacket - With TUP Version 3
func (tup *TarsUniPacket) InitVerion3() {
	tup.IVersion = 3
	tup.Buffer = PacketBuffer{
		IVersion: 3,
		NewData:  make(map[string][]byte),
		Data:     make(map[string]map[string][]byte),
	}
}

// SetVersion for TarsUniPacket
func (tup *TarsUniPacket) SetVersion(version int16) {
	tup.IVersion = version
	tup.Buffer.IVersion = version
}

// SetPacketType for TarsUniPacket
func (tup *TarsUniPacket) SetPacketType(packageType int8) {
	tup.CPacketType = packageType
}

// SetMessageType for TarsUniPacket
func (tup *TarsUniPacket) SetMessageType(messageType int32) {
	tup.IMessageType = messageType
}

// SetRequestId for TarsUniPacket
func (tup *TarsUniPacket) SetRequestId(requestId int32) {
	tup.IRequestId = requestId
}

// SetServantName for TarsUniPacket
func (tup *TarsUniPacket) SetServantName(name string) {
	tup.SServantName = name
}

// SetFuncName for TarsUniPacket
func (tup *TarsUniPacket) SetFuncName(name string) {
	tup.SFuncName = name
}

// SetTimeout for TarsUniPacket
func (tup *TarsUniPacket) SetTimeout(timeout int32) {
	tup.ITimeout = timeout
}

// SetContext for TarsUniPacket
func (tup *TarsUniPacket) SetContext(context map[string]string) {
	tup.Context = context
}

// SetStatus for TarsUniPacket
func (tup *TarsUniPacket) SetStatus(status map[string]string) {
	tup.Status = status
}

// Get from TarsUniPacket
func (tup *TarsUniPacket) Get(key string, value interface{}) error {
	return tup.Buffer.get(key, value)
}

// Put into TarsUniPacket
func (tup *TarsUniPacket) Put(key string, value interface{}) error {
	return tup.Buffer.put(key, value)
}

// Decode from []byte
func (tup *TarsUniPacket) Decode(buff []byte) error {
	pack := requestf.RequestPacket{}
	is := codec.NewReader(buff[4:])
	if err := pack.ReadFrom(is); err != nil {
		return err
	}

	tup.IVersion = pack.IVersion
	tup.Buffer.IVersion = pack.IVersion
	tup.CPacketType = pack.CPacketType
	tup.IMessageType = pack.IMessageType
	tup.IRequestId = pack.IRequestId
	tup.SServantName = pack.SServantName
	tup.SFuncName = pack.SFuncName
	tup.ITimeout = pack.ITimeout
	tup.Context = pack.Context
	tup.Status = pack.Status

	is1 := codec.NewReader(tools.Int8ToByte(pack.SBuffer))
	if err := tup.Buffer.readFrom(is1); err != nil {
		return err
	}

	return nil
}

// Encode to []byte
func (tup *TarsUniPacket) Encode() ([]byte, error) {
	if tup.SServantName == "" || tup.SFuncName == "" {
		return nil, errors.New("servantName and funcName is required")
	}
	os := codec.NewBuffer()
	if err := tup.Buffer.writeTo(os); err != nil {
		return nil, err
	}
	pack := requestf.RequestPacket{
		IVersion:     tup.Buffer.IVersion,
		CPacketType:  tup.CPacketType,
		IMessageType: tup.IMessageType,
		IRequestId:   tup.IRequestId,
		SServantName: tup.SServantName,
		SFuncName:    tup.SFuncName,
		SBuffer:      tools.ByteToInt8(os.ToBytes()),
		ITimeout:     tup.ITimeout,
		Context:      tup.Context,
		Status:       tup.Status,
	}

	os1 := codec.NewBuffer()
	if err := pack.WriteTo(os1); err != nil {
		return nil, err
	}

	result := make([]byte, 4)
	result = append(result, os1.ToBytes()...)
	binary.BigEndian.PutUint32(result[:4], uint32(len(result)))

	return result, nil
}
